# テストの構築

## 目次

- 4-1 自己テストコードの意義
- 4-2 テストのためのサンプルコード
- 4-3 最初のテスト
- 4-4 テストの追加
- 4-5 フィクスチャの変更
- 4-6 境界値の検査
- 4-7 これより先には

## 【前書き】

- リファクタリング は価値のあるツールだが、単体では成り立たない
- 何らかの誤りが必ずあり、それを指摘してくれる堅牢なテストスイートが必要

  - テストスイート（test suite）
    - 特定のテストサイクルで実行される テストケースやテスト手順のセット
    - 「テストの目的や条件が似ている複数のテストケースを一括りにまとめたもの」
      - テストスイートとは何か？ 例を用いてわかりやすく解説
        - https://q-media.jp/test-suite/

- テスト は足かせにはならない
- 良いテスト を書くとプログラマとしての生産性が高まる
  - これは予想外のこと。普通は、テストを書く工数が増える、とかいう認識になる
  - これは、テストを"実際に"書いた人にしか分からない（後で書いてる）

## 4-1 自己テストコードの意義

### プログラマの時間の使い方

- 実際にコードを書いている時間は極めて短い
- 何が起こっているかの把握 / 設計とか
- 一番時間がかかるのは、デバッグ

### 自己テストコードの道に入るようになったきっかけ

- (会話の中で)「クラスにそれ自身のテストを行わせるべき」
- テストを含めるようにした
  - テストは依然としてきわめて退屈なもの
    - テスト結果を毎回自分でチェックしなければならなかったから
- 自分で調べるのをやめて PC に調べさせればいい
  - テストコードに、期待される値を書いて、結果と比較させれば良い
    - テストを実行して、「OK」が出力されるか確認するだけ
      - ソフトウェアが「自己テスト」をするようにした

### すべてのテストを完全に自動化し、テスト自身に結果をチェックさせること

- テストによって、大幅に生産性が向上した
  - デバッグに時間がかからなくなったから
    - バグが入ってもテストの実行で検出できる
      - バグが発生した場合、直前のテスト以降の作業 で発生したことが分かる

### テストを一揃いにしておくと、バグ検出に絶大な威力を発揮する。これによって、バグの発見にかかる時間は削減される。

- 「テストを書く」という方法 を取るように、他者を説得するのは簡単ではない
  - テストの記述は、大量の余計なコードを書くことを意味するから
    - これによって、どれだけプログラミングが速くなるかを実際に体験しなければ、テストが意味のあることとは思えない。
- 手動で行うテストは、はらわたがちぎれるほど退屈（？？）
  - でも自動でできるなら、テストを書くこと はとても楽しいものになる
- 実際のところ、テストは「プログラミングを始める前」に手をつけるのが良い
  - 「新しい機能を追加する時」はテストから書き始めるのが良い
    - これは後ろ向きな印象ですが、全く違う
- テストを書くことで、
  - 「機能を追加するためにすべきことは何か」を自問することになるから
  - 実装よりも「インタフェース（機能や動作）」に集中することになるから
  - 「コーディングが完了する時点」も明確になる
- Kent Beck 氏が、このテストファーストの習慣を、テスト駆動開発（TDD）という形でまとめた
  - テスト駆動開発（TDD）: test-driven development
    - Test: まず（失敗する）テストを書く
    - Coding: テストが通るようにプログラムを書く
    - Refactoring: そのあとでコードのリファクタリングをする
      - という短いサイクルを繰り返す方式
- 本書はテストではなく、リファクタリングの本
  - でも、リファクタリングにはテストが必須
  - リファクタリングするなら、テストを書かなくてはならない

## 4-2 テストのためのサンプルコード

- テストの例となるコードを示します。
  - ユーザが製品の生産計画を調べたり調整したりするための、簡単なアプリケーション。
- （Topic）
  - ビザンチウム（現在のイスタンブール）とアッタリア、そしてシノプは、現在のトルコ地域にあった重要な古代の都市です。

### UI

- 生産計画 の画面には、地域ごとに 需要 と 価格 が表示されている。
- 地域ごとに 生産者 がいて、設定された価格 で 一定量の生産 が可能
- 生産量の全てが売れた時に、生産者がどれだけの収入を得るか も確認できるようになっている
- 下のエリアに、この計画における生産量の不足分（需要 から 総生産量 を引いたもの）と、利益 が表示
- ユーザは UI から、需要や価格、個々の生産者の生産量やコストなどのパラメータを変更して、不足分や利益の変化を確認できる。
- 編集可能な項目の数値を変えると、即座に関連する値も更新される

### 計算詳細（利益 はなぜ 230 になる？）

#### demandValue（需要価格）

- 需要は 30 で、総生産量は、各生産量：ビザンチウム が 9、アッタリア が 10、シノプ が 6 なので、 25 となります（satisfiedDemand）。
- 価格は 20 なので、25 × 20 = 500 となります（demandValue）。

#### demandCost（需要コスト）:

- 各貢献分をそれぞれの原価で掛けて、その結果を合計します。
  - コスト × 生産量
  - すなわち、(10 × 9) + (12 × 10) + (10 × 6) = 90 + 120 + 60 = 270 となります。

#### 利益

- profit は 需要価値 500 から 需要コスト 270 を引いた結果、500 - 270 = 230 となります。
  - このため、「利益」は 230 と表示される。

## ビジネスロジック の部分に焦点を当てる

- つまり、利益 と 不足分 の計算を行う箇所のこと
  - UI の仕組み から切り離すことで、ビジネスロジックの理解 や テスト がしやすくなる
    - UI: HTML 生成 や フィールド表示更新など

### ビジネスロジックのコードは二つのクラスから成り立っている

- 個々の生産者
  - class Producer （生産者）
- 地域
  - class Province （県都）

## 4-3 最初のテスト

- テストフレームワークとして Mocha を紹介しています。
  - Mocha（モカ - モッチャじゃない）
    - 公式：https://mochajs.org/
    - Mocha は、 Node.js およびブラウザーで実行される機能豊富な JavaScript テストフレームワーク
  - Chai（チャイ）
    - アサーション のライブラリであり、よく一緒に用いられます。
- ※ここからコードを参照

```
最初の2行：Chaiライブラリからassertをインポートし、プロジェクトのローカルファイルからProvinceとsampleProvinceDataをインポートしています。
Chaiのassert位置は、テストケースを検証するためのアサーション機能を提供します。
Provinceはテスト対象のモジュールまたはクラスであり、sampleProvinceDataはテストケース実行時のサンプルデータです。

describe関数：Mochaのdescribe関数はテストの組（テストスイート）を作成します。
この場合、"province"という名前のテストスイートを作成しています。

it関数：it関数はMochaで個々のテストケースを作成します。
この場合、it関数は"shortfall"という名前のテストケースを作成しています。
一つのdescribeブロック内には複数のitブロックを作成し、異なるテストケースを作成することができます。

テストケースの実行：テストケースの中で、まずsampleProvinceDataを使って新しいProvinceオブジェクトasiaを作成します。
その後、このオブジェクトのshortfallプロパティが5であることをassert（主張）しています。
もしshortfallが5でなければ、テストは失敗（fail）し、その失敗の理由が出力されます。
```

## 4-4 テストの追加

- クラスがなすべきことをすべて調べた後、それらについて一つずつ、失敗しそうな条件 でテストする。
- テストはリスク主導
  - 単純なテスト はバグを見落とす
  - 一番怪しいと思う部分を集中的にテストすることが大事
- フィクスチャ？

```
テストフレームワークにおける「フィクスチャ」（fixture）は、テストを実行するために必要な 固定の環境やデータ のことを指します。
フィクスチャは、テストケースが期待した結果を正確に返す状態を確立するために使用されます。
テストデータ、設定情報、ダミーオブジェクト、スタブ、モックなど、必要なリソースの全てがフィクスチャに含まれることがあります。

上記のコードでは、`sampleProvinceData`関数がフィクスチャの役割を果たしています。
それは`Province`オブジェクト（`asia`）を初期化するのに使用され、テストケースの実行中に必要なデータを提供します。
このフィクスチャは各テストケースで利用されており、`shortfall`と`profit`のプロパティが期待する値であることを確認します。
```

- ※ここからコードを参照
  - profit test
  - bad case
  - good case

## 4-5 フィクスチャの変更

- これまでのテストは、フィクスチャを一回だけロードして、オブジェクトの属性が期待される値になるかを確認するものだった
  - 実際の利用時にはユーザは値を変えるので、フィクスチャは定常的に変更されます。
- 大抵、単純な setter で起こる。しかし、バグの原因になることはほとんどないので、ここのテストは逐一しない。
- Producer クラス の setter のテスト
  - ただし、Producer（生産者）クラスで定義された setter の production（生産量）は、複雑な処理が含まれているので、テストした方が良い。
- beforeEach でテストする前の共通動作をまとめることができる
- 強く関連していれば、同じ箇所にまとめて問題ない。it ブロックの分割は、あとで分けることも可能。

## 4-6 境界値の検査

- ハッピーパス
  - 全てが順調な時に予想された状態になることを確認するためのもの
- 条件の境界の箇所で、通常と異なる時に何が起きるかをテストすることは有効
  - 0 / 負 / 空 の値 の時にどうなるか
  - 失敗する可能性のある境界条件を考えて、そこを集中的にテストすること。
- 最後のテストは Mocha 上では失敗するが、単にテストが失敗すること にはならない
  - 通常のテスト失敗ではなく、テスト実行エラーとする。

### アサーションの導入

- アサーションは、常に真であること を前提にした条件文

```
if (this.discountRate)
  base = base - (this.discountRate * base)
```

↓

```
assert(this.discountRate >= 0); // 常に真であること を前提にした条件文
if (this.discountRate)
  base = base - (this.discountRate * base)
```

- 白黒はっきり付けた結論 は書かれていないが、
- テストは書こう
- テストを本気でやりすぎないようにしよう
- 大事なところを中心にテストを書こう

## 4-7 これより先には

### テストについて

- この本はリファクタリングの本なので、テストの本ではない
- しかし、「テスト」 は重要なトピック
  - リファクタリングに不可欠な基礎となるもので、それ自身が価値あるツール
    - 昔は分離した（そして下位の）グループの責任と考えられてきた
    - 現在は、ソフトウェア開発者 にとって、第一の関心ごとになってきている
      - 例）テストが用意可能かどうかで、アーキテクチャが判断されるようになった

### 本章のテストは、いわゆる単体テスト

- コードの特定部分を対象とし、素早く実行できるように設計されるもの
- ほとんどのテストは単体テスト
  - 他の種類のテストも存在しますが。
- 新機能を加えると同時に、テストも追加していく
  - 既存のテストコードに目を向ける動きにつながる。
  - （イマココ）テストが無いファイルがイーデスにたくさんある
- テストを書く、ということは大事な習慣

### どれだけテストすれば十分か

- 適切な指標は無い
  - テストカバレージ
    - コードの中のまだテストされていない箇所を突き止める場合のみ有効
    - テストスイート自体の品質 を保証するものではない
- 十分なテストスイートが揃っているかどうか
  - 主観で決めるのが最も良い
    - 誰かがバグを埋め込んだらちゃんとテストが失敗するか、確信を持てるように
- テスト過多 より テスト不足の現実が多い
  - （イマココ）テスト不足
