# リファクタリングの原則

## リファクタリングの定義

- リファクタリングは、コードを「理解や修正が容易になるように変化させていくもの」
- パフォーマンスチューニングでは、プログラムの実行速度を上げることに注力します
  - もしも速度の改善が本当に必要なら、コードが扱いにくいものになるのも厭わない

### リファクタリングする (動詞)中にはリファクタリング (名詞)が含まれてる

- リファクタリング (名詞)
  - 外部から見たときの振る舞いを保ちつつ、理解や修正が簡単にな るように、ソフトウェアの内部構造を変化させること。
- リファクタリングする (動詞)
  - 一連のリファクタリングを適用して、外部から見た振る舞いの変更なしに、ソフトウェアを再構築すること。

### 一度に行えそうな場面でも非常に小さなステップを踏む

非効率だが、各要素が秩序だった形に進めることでリファクタリングを速く進行できる

### 「外部から見た振る舞い」 という言葉

作業の開始前と比べて、総じて同じ動作をすべき

## 機能追加とリファクタリングを区別する

- 機能追加を行うときには、既存のコードを変更せず、リファクタリングをしているときには、機能追加は行わない
- （漏れていない場合）テストケースも追加しない

## リファクタリングを行う理由

### リファクタリングはソフトウェア設計を改善する

**認知負荷が高まる構造**

- 開発者が短期的な目的の実現のため、アーキテクチャの全体的な理解をせずに変更を行う
  → 　コードは構造を失う
  → 　累積的に悪影響
  → 　設計が把握しづらくなる
  → 　維持するのが困難になり急速に劣化
- 重複部分を排除すること
  → 　コードがただの 1 回のみ書かれている
  → 　そこですべてが処理されることを保証されている
  → 　優れた設計

### リファクタリングはソフトウェアを理解しやすくする

ソースコードは「読むこと」を行う利用者の存在は軽視してはならない

- コードを理解しやすくしていくにはリズムの変化が必要
- 後から調べられることは覚えないようにする
- 覚えておくべき情報をコード内に書き込んでおく

### リファクタリングはバグの発見を助ける

リファクタリングによって、堅牢なコードをずっと効果的に書けるようにする

- 偉大なプログラマではなく、偉大な習慣を身に付ける

### リファクタリングはプログラミングを速める

内部の設計が改善され、理解がしやすくなり、バグが少なくなるということは、すべて品質に貢献する

- ソフトウェアは既存コードベースに新機能をどう適合させるかを把握するのに費やす時間が、徐々に増えていく
- 追加したとしても、バグが起こり、修正にはさらに時間がかかる
- 動いているかを突き止める考古学の様相を帯びる
- すぐれた設計を前もって完了しておくことは非常に難しいので、すばやく機能を追加し続けるには、リファクタリングが不可欠

## いつリファクタリングをすべきか

三度目に同じようなことをしていると気づいたら 100%リファクタリング

### 準備のためのリファクタリング - 能追加を容易にするために

- 既存のコードに機能を追加する前が最適

例：パラメータによる関数の統合

非常に似た関数にパラメータを持たせ、関数の有用性を高める

```js
function tenPercentRaise(aPerson) {
  aPerson.salary = aPerson.salary.multiply(1.1)
}
function fivePercentRaise(aPerson) {
  aPerson.salary = aPerson.salary.multiply(1.05)
}
```

↓

```js
function raise(aPerson, factor) {
  aPerson.salary = aPerson.salary.multiply(1 + factor)
}
```

### 理解のためのリファクタリング - コードをわかりやすくするために

- コード変更前に理解が重要
- 自身のコードか他人のかを確認し、複雑な部分はリファクタリング
- 理解をコードに取り込み、テストで確認
- 他の開発者にも伝えるためにリファクタリング
- 初期のリファクタリングは新たな理解を得るチャンス

### ゴミ拾いのためのリファクタリング

- コードは理解できるが書き方が改善できる場合のリファクタリング
- 入り組んだロジックや重複する関数を整理する
- リファクタリングはトレードオフがあり、タスクとの兼ね合いが必要
- 現在のタスクに直接関係ないことに時間を割きたくないが、将来の変更を妨げないためにも対応が必要
- 容易な場合はすぐに実行し、難しい場合は後で対処
- タスクが終わった後に取り組む際にはメモを活用

### 計画されたリファクタリングと、機に応じたリファクタリング

- ソフトウェア開発において、リファクタリングの重要性が認識されている
- リファクタリングはコードの改善を目指し、準備、理解、ゴミ拾いのために行われる
- リファクタリングはプログラミングの自然な流れとして捉えるべき
- 機能追加やバグ修正の最中にもリファクタリングを取り入れ、コードを適切な形に保つ
- 醜いコードや素晴らしいコードの両方がリファクタリングを必要とする
- コードのトレードオフを意識し、現実に合わせてリファクタリングを行うことが重要
- ソフトウェア開発は累積のプロセスであり、リファクタリングは欠かせない
- 計画されたリファクタリングは悪いことではないが、機に応じてリファクタリングを行うことが一般的
- リファクタリングと新機能追加を分けるアプローチには賛否がある
- 開発チームでの試行を通じて適切なリファクタリングのアプローチを見つけることが重要

### 長期のリファクタリング

- 通常は数分から数時間の短い期間で行われるが、1 週間以上かける大規模なリファクタリングもある
- 既存のライブラリを新しいものに置き換えたり、依存性を整理する場合が該当
- チーム全体で徐々に問題を解決し、リファクタリングに専念することはお勧めしない
- リファクタリングの方向性はチームで合意し、徐々に変更を加えていく
- リファクタリングはコードの壊れるリスクを最小限に抑えながら行うべき
- ライブラリの置き換えには新たな抽象レイヤを導入し、既存のコードを修正しておくことが有用

### コードレビュー時のリファクタリング

- 定期的なコードレビューは組織機能と知識共有に有益
- コードレビューは明快なコードを促進し、新たなアイデアやアプローチを引き出す機会
- レビューを通じて多くの人の意見が反映され、達成感が生まれる
- リファクタリングはコードレビューに組み込まれ、他人のコードを評価しつつ改善も行う
- コードレビューにはプルリクエスト方式やペア・プログラミングのアプローチが適用される
- コードレビューとリファクタリングはプログラミングの一環として常に取り入れるべき

### 管理者を説得するには

- リファクタリングはソフトウェア開発速度を向上させる重要な手段
- リファクタリングは新機能の追加やバグ修正を効率的に行うために必要
- 管理者はスケジュールと効率を重視するため、最速の方法を選ぶことを支持

## リファクタリングの問題点

リファクタリングはトレードオフであるが定量化が非常に困難で、少ない労力で多くの価値を生み出すべく行為

### 新機能の実装が遅くなる

- リファクタリングに時間をかけることで新機能実装が遅くなるとの誤解がある
- リファクタリングは開発速度を上げることが目的
- 適切なリファクタリングは労力を最小限に抑えて価値を最大化する
- リファクタリングと新機能追加のトレードオフは主観的で経験に依存
- 新機能の実装が楽になるためのリファクタリングは有益
- 健康なコードベースでの開発経験が重要
- リファクタリングを軽視する管理者や開発者も存在
- チームの技術リーダーがリファクタリングの重要性を示すべき
- リファクタリングは経済的な基準により評価すべき
- リファクタリングは速度向上と経済的効果を追求するために行うべき

---

ここでブレイク

### 言葉の定義

parts→components→module

- parts は個々の部品
- components は parts がいくつか合わさって機能を持った状態
- module は装置を構成する機能としてまとまった交換可能な構成体

parts は全体の一部分であり、主役は全体でそれを支えているのが parts だと考えることができる。
一方の component はそれ単独でも主役になることができ、それが全体の一部を構成している。
module は単独でも機能としては成立するが、普通は他のものと組み合わせて使う

ブレイクここまで

--

### コードの所有権

- リファクタリングは他の部分との関連性を含むことが多い
- リファクタリングが制約される主な理由は、関数呼び出し側の所有権と影響範囲
- コードの所有権が厳密であると、リファクタリングに制約が生じる
- インタフェースの変更に対する対価として、古いインタフェースを保持することがある
- 開発者間でコード所有権を細かく設定することはリファクタリングに反対する可能性がある
- 寛容な所有権ルールを採用することで、チーム内外のコード変更が容易になる
- オープンソース的なやり方では、分岐とコミットを通じて変更を管理しやすくする方法がある

### ブランチ

- 開発チームでは、コードベースからブランチを切って作業し、メインブランチに統合するのが一般的
- メインブランチには中間段階のコードを含まず、リリースのバージョン履歴が整然と保持される
- 長い機能ブランチはマージの問題を複雑にし、頻繁なマージやリベースを行うことがある
- マージと統合を区別し、双方向の流れを考えることが重要
- 機能ブランチが長くなるとマージの問題が指数関数的に悪化する
- 継続的インテグレーション (CI) では、ブランチを短く保ち、毎日メインブランチと統合することが一般的
- CI はリファクタリングと調和するため、コードの修正におけるマージ問題が起きやすい
- CI は効率的なソフトウェア配布に貢献し、機能ブランチ方式との比較で検討が重要

### テスト

- リファクタリングは外部の振る舞いを変えないようにする
- テストスイートを持つことが重要。テストは頻繁に実行し、すばやく行えるようにする
- 自己テストコードを書くことで、リファクタリングの安全性向上し、新機能追加も容易になる
- バグ発見は差分から行えるため、テストの頻繁な実行が重要
- 自動リファクタリングツールを使用する場合、テストを走らせずに安全なリファクタリングが可能
- リファクタリングに制約を加えるスタイルもあり、言語やチームによって異なる
- テストと自己テストコードは継続的インテグレーションや継続的デリバリーに重要な役割を果たす

---

テストスイートとは

- ソフトウェアテストの目的や対象ごとに複数のテストケースをまとめたもの
- 最小単位はテストケース
- テストケースを組み合わせ、かたまりを「テストスイート」と呼ぶ

---

### レガシーコード

- レガシーコードは複雑でテスト不足であることが多い
- リファクタリングはレガシーコードを理解する助けになるが、テストの存在が重要
- テストを追加することが解決策。しかし、既存のシステムにテストを追加するのは難しい
- テストを挿入できる接合部を見つけ、自己テストコードを導入して保護する
- レガシーシステムのリファクタリングは小さなステップで進めるべき
- 頻繁に訪れる箇所を重点的にリファクタリングする

### データベース

- データベースのリファクタリングは進化的なデータベース設計の手法により可能になった
- データベースの構造的な変更やデータ移行はスクリプトを活用して行われる
- フィールド名変更などの変更は小さな単位に分割して進める
- データベースの変更は複数のリリースに分割し、変更を取り消しやすくする
- 変更手法の一例として「拡大と契約」パターンが挙げられる

## リファクタリングとアーキテクチャ、 そして Yagni

Yagni（You aren't gonna need it） - どうせ必要にならない

- リファクタリングはアーキテクチャに新たな視点をもたらし、ソフトウェアの設計を変革した
- 以前のアーキテクチャではコードが固定化され、リファクタリングの考え方は変化を可能にした
- レガシーシステムの設計改善はテストが不十分で難しいが、リファクタリングは変化に柔軟に対応する方法を提供する
- 事前に完璧なアーキテクチャを立てる代わりに、リファクタリングを通じて柔軟性を持たせた設計を採用することで、要求の変化に対応できる
- 小さな柔軟性の仕組みを採用し、必要な時にのみ追加することが重要である
- Yagni（You aren't gonna need it）の考え方は、必要でない機能や柔軟性を避け、変更に対応する柔軟な設計を重視するもの
- リファクタリングを通じてアーキテクチャの見直しを組み込むことで、進化的アーキテクチャが可能になる
- アーキテクチャの決定は進化的に行い、パターンやプラクティスを探求することが重要

## リファクタリングとソフトウェア開発プロセス

- リファクタリングと他の開発プラクティスの組み合わせが効果的
- エクストリーム・プログラミング (XP) はリファクタリングを早期から実践。アジャイル開発の一環として広まる
- リファクタリングには自己テストコードが必要であり、継続的インテグレーション (CI) が重要
- チーム内のリファクタリングを干渉せずに行うために、CI を推奨
- 自己テストコード、継続的インテグレーション、リファクタリングの相乗効果があり、Yagni の設計手法を実践する基盤を提供
- コアのプラクティスが確立されれば、アジャイル開発手法の他の要素も活用可能
- 継続的デリバリーにより、リリース可能な状態を維持し、信頼性を高め、アイデアを製品に迅速に反映できる
- ソフトウェア開発は複雑で厄介なプロセスであり、効果的な実践とスキルが必要

## リファクタリングとパフォーマンス

リファクタリングは一時的に速度を低下させることがあるが、最適化の際に有利な状態を作り出す。
結果的に、リファクタリングとパフォーマンス最適化の組み合わせによって、効率的で高速なソフトウェアを実現することが可能となる。

- リファクタリングがプログラムの速度性能に与える影響は重要であり、懸念される要素
- ソフトウェアの理解を容易にする変更がプログラムの実行速度を低下させる可能性があるが、設計の純粋さを維持し、パフォーマンスを無視することは望ましくない
- 速いソフトウェアを作成すること方法
  - 実行スケジューリング
    - ハードリアルタイムシステムでは一般的。設計を細かなコンポーネントに分割し、各コンポーネントに時間とメモリのリソースを割り当てる。ただし、一般の企業情報システムでは必ずしも適用する必要はない。
  - 常にパフォーマンスを意識する方法
    - 全てのプログラマがパフォーマンスを重視し、工夫をする。しかし、この方法はプログラムの複雑さを増し、開発効率を損なう可能性がある。
  - 90%の法則を活用したパフォーマンスチューニング
    - プログラム全体にわたる均等な最適化よりも、実行時間の大部分を占めるホットスポットに集中的にチューニングする。プロファイラを使用してホットスポットを特定し、効果的な最適化を行う。
- この最適化方法を適用する場合、プログラムがリファクタリングで整理されていると、効果が増す
  - プログラムの整理によってパフォーマンスのボトルネックを特定しやすくなり、最適化の段階でより効果的にチューニングできる

### 何も作り出さないことにかけた時間

推測は間違っている。実際に計測しよう。

## リファクタリングの起源

- 「リファクタリング」という言葉の起源や初期の概念については不明
- ソフトウェアの整理や品質向上の考え方は古くから存在
- リファクタリングはコード整理のアイデアを発展させたもので、Ward Cunningham と Kent Beck が重要な役割を果たした
- 彼らは 1980 年から Smalltalk でリファクタリングを実践し、開発プロセスと結びつけた
- リファクタリングのアイデアは Smalltalk コミュニティに影響を与え、Ralph Johnson も重要な役割を果たした
- Bill Opdyke は C++でのリファクタリングを研究し、その有用性を探求。彼の研究が初期の成果
- John Brant と Don Roberts が初のリファクタリングツール「リファクタリング・ブラウザ」を開発
- リファクタリングの効果を知り、重要性を認識した著者は初版の本を執筆
- リファクタリングの考えが業界に広がり、特に Java 界隈でリファクタリングツールの開発が進む

## 自動化されたリファクタリング

- 過去 10 年間で最も大きな変化は、自動化されたリファクタリングツールの利用が広がったこと
- ツールを使用することで、メソッド名の変更などが簡単に行えるようになった
- 最初の自動化リファクタリング機能は、Smalltalk の「リファクタリング・ブラウザ」で提供された
- Java コミュニティで自動化リファクタリングが広まり、JetBrains の IntelliJ IDEA などの IDE が競争力を持つ主要機能となった
- C#でも ReSharper などのプラグインが登場し、Visual Studio 自体もリファクタリング機能を強化した
- エディタやツール群でもリファクタリングをサポートするものが増えてきているが、機能の差異はツールやプログラミング言語の制限による
- リファクタリングには、構文木を操作することが重要。IDE がこれをサポートし、コードのナビゲーションや静的解析なども行える
- 静的型付けの言語ではリファクタリングが安全に行いやすく、テストを走らせる必要が少なくなる
- 進んだツールでは、変数名の変更に伴うコメントの変更や関数の抽出と呼び出しの提案なども行える
- リファクタリングツールを組み合わせて使用し、自動化と手作業を組み合わせてテストを頻繁に実行するのが賢明
- 構文木を使用する技術は強力であり、言語サーバという技術も広まってきており、さまざまなエディタに対応したリファクタリングが可能
